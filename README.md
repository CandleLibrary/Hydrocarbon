<h1 align=center>
    <img src="./flavor/cfw-flame-w-lib.svg" type="text/svg" rel="svg" height=80>
</h1>

<h3 align=center>Recursive Descent Parser Compiler</h3>

<p align=center> <sub><b>v0.7.1</b></sub> </p>

Recursive, unlimited look ahead. that handles grammar ambiguities Forking or Backtracking. It can create parsers from *left-recursive* grammars (and it's even is preferred to write grammars this way). It allows multiple grammar definitions for
different languages to be combined into one parser. The recognizer is designed to be language agnostic and recognizers can be generated for languages other than TypeScript/JavaScript

Use a special grammar definition syntax that designed to be flexible and easy to read. 
Reads custom **.hcg** grammar files and builds recursive descent parsers. Currently supports parser targets for Javascript, Typescript, and WebAssembly

# Usage

## Write A Grammar

```ini
# my_json_like_language.hcg
@IGNORE g:ws g:nl

<> JSON > object                                   

<> value > object
    | array
    | t:true                                        f:r{ true }
    | t:false                                       f:r{ false }
    | t:null                                        f:r{ null }
    | tk:number                                     f:r{ parseFloat($sym1) }
    | tk:string                                     f:r{ $sym1.slice(1,-1) }

<> object > \{  element(*\, )  \}                   f:r{ Object.fromEntries($$sym2 || [])  }

<> element > tk:string \: value                     f:r{ [$sym1.slice(1,-1), $sym3] }

<> array > \[ value(*\, ) \]                        f:r{ $$sym2 || [] }

<> number > g:num ( \. g:num )? ( \e g:num )?

<> string > \" (RST g:nl) ( g:id | g:num | g:sym )(*) \"
```


## Install Hydrocarbon & Compile Parser
```bash
:~$ yarn global add @candlelib/hydrocarbon

:~$ hydrocarbon compile --recognizer wasm --completer js \./my_json_like_language.hcg
```

## Use the parser

```js
import json_parse from "./parser.js";

const { result } = json_parse('{"Hello World":[3, 1, 4, 1, 5, 9.265] }');

result[0]        // => { 'Hello World' : [3, 1, 4, 1, 5, 9.265]  }
typeof result[0] // => "object"

```

# Motivation

The primary reason this exists is to provide a flexible, easy to use parser compiler to handle the parsing demands of CandleLibrary libraries such as Wick, JS, TS, Wax, and CSS. It provides a way of rapidly define new language syntax and is able combine grammars of different languages into one meta-parser. 

Parsers are not fun to create; there are many edge cases, optimization pitfalls, and design. They are a means to an end that can take up significant part of the *"means"*.

# CLI Usage

### ``hydrocarbon compile <arguments?> <file path to .hcg>``

Compiles a parser from a Hydrocarbon grammar file

### Optional Arguments
| Argument | Value | Description |
|--|:--:|--|
| `--workers` |  `<number>`| Number of worker threads used to compiler parser. <br> Defaults to 1|
| `--output_dir` |  `<file path>`| Output directory for parser.<br> Defaults to the CWD|
| `--name` |  `<string>`| Name to give the parser file.<br> Defaults to 'parser'|
| `--recognizer_type` |  `<js \| wasm>`| Type of recognizer to create may either be `wasm` or `js`.<br> Defaults to `js`|
| `--completer_type` |  `<ts \| js>`| Type of recognizer to create may either be `ts` or `js`.<br> Defaults to `js`|
| `--annotations` | none | Add annotated comments to recognizer.<br> Only applicable when the recognizer is a `js` type.|

# Contribution

If you have any problems using hydrocarbon, or would like to suggest a new feature, please open an [issue](https://github.com/CandleLibrary/hydrocarbon/issues).

If you would like to contribute to the development of hydrocarbon, fork the repository, create and develop on a new branch, and create a pull request from your forked repo.


# Parser Design

The core functionality of a Hydrocarbon parser is split across two major parts, a **recognizer** and a **completer**. 

The **recognizer** performs the heavy lifting by parsing a text input, identifying sequences of text that belong to productions of the grammar, and generating parse actions. There are four actions the recognizer can issue: ACCEPT, SHIFT, REDUCE, and SKIP. These actions are encoded in 32bit integers and stored in an action buffer. 

The **completer** reads actions from the action buffer, and applies them to the text input. It may also call user defined functions that accepts tokens generated by SHIFT actions. These functions may optionally return values that can be received by other custom functions. Both tokens, and values returned from the custom functions, get pushed to an output stack, which then returned by the **completer** once it finishes applying the parse actions. A primary use of the **completer** is to construct ASTs (Abstract Syntax Trees) from the text input, but it can be used for other tasks such as generating text highlighting or serving as a script interpreter.

The split functions allow the **recognizer** to be defined using C/C++ friendly syntax that is then compiled to a WASM module. The **completer** is written in TypeScrip/JavaScript. Future work will allow both the completer and the recognizer to be used in  languages other than TypeScript/JavaScript.

# Grammar

## Symbols

### Defined Symbols 

Any terminal symbol that is defined using the forward slash `\` operator or otherwise is not a `production` non-terminal nor is operator of the Hydrocarbon grammar. Within this definition, Hydrocarbon further defines three separate  defined types:
- Defined Numeric:
    A discrete sequence of numerical characters within the ASCII range `0x30`to`0x39`, inclusive
    <br/> e.g: `\0123456 \321 \01110111` 

- Defined Identifier: 
    A discrete character sequence beginning with a Unicode character within the Unicode ID_Start character class. 
    <br/> e.g: `\symbol \function \01110111` 

- Defined Symbol: 
    Any character sequence that does not fall under the proceeding definitions.
    <br/> e.g: `\:warning:  \=NOT_VALID=   \===` 

### Generic Symbols

Hydrocarbon provides several "generated" terminal symbols that match a sequence of characters based on a preset pattern. There
are four generic symbols that can be used within a grammar definition:

- Generic Identifier: A sequence of characters starting with a character that belongs to the Unicode ID_Start class followed by any number of characters that belong to the Unicode ID_Continue class. 
    <br/> e.g: `g:id` 
- Generic Natural Number: Any number of characters within the ASCII range `0x30` to `0x39`. 
    <br/>RegEx definition: `[0-9]+`  e.g: `g:num` 
- Space: Any number of space characters, including ASCII code point `0x20` and characters belonging to the `WS` Unicode class. Also matches tab stop code points.
    <br/> e.g: `g:ws` 
- New Line: Any number of ASCII code points `0xA` and `0xF` to match `<LF>` and `<CRLF>`
  <br/> e.g: `g:nl` 
- Generic Symbol: Any SINGLE code point that does match one of the proceeding definitions for generic symbols
  <br/> e.g: `g:sym` 

### Production Token Symbols

A production can be treated as a single terminal symbol by prefixing the production name with`tk:`, such as `tk:function` for a production `<> function > ...`. 
By doing so, all characters that are recognized by the production will be combined into a character sequence string that serves
as the value of the production token symbol. 


## Operators

There a several operators that can be applied to symbols to direct the recognize to apply a particalure action on that symbol.

- Escape `\<symbol>`

- Optional `<symbol>?`

- One or more `<symbol>(+)` 
    Instructs the recognizer to expect one or more iterations of the proceeding symbol within the input.

- One or more as a string `<symbol>(+\' )`

- Zero or more `<symbol>(*)`
    Instructs the recognizer to expect zero or more iterations of the proceeding symbol within the input.
    This operator can augmented to cause the recognizer to assert the presence of a delimiter between iterations, 
    > such as `g:sym(*\, )` which would match a string of symbols delimited by commas: `$,%,^,&,#`
- One or more as a string `<symbol>(+\' )`


# Grammar Todo
- Flatten Repeating productions
- Convert grammars to ASTs and process after parses are complete
- Look for mistakes and automatically remove them or warn about them
    - duplicate productions bodies
    - Unmatched sentinels

# Feature Road-Map
## Version 1 Feature set

- [*] Grammer for creating parsers 
- Compile parser for use TypeScript/Javascript with Web Assembly Recognizer
- Production Selection to parse individual productions instead of the goal production
- TypeScript Definitions for parser, recognizer & environment
- Documentation for the above features.

## Version 2 Feature set
- Streaming Parsing & Restartable recognition 
- Parallel Parsing - Allow blocks to be parsed concurrently
- Automatic AST generating 
- Online Demonstration 
- Syntax Highlighting Plugin
- Revisions to Grammer
- Support for other grammar files.

## Version 3 Feature set
- Rewrite parser compiler in a compiled language
- Make parser front end for other languages

# Contributing

This is an experimental project that I'm able to work on in the increasingly fleeting moments of spare time that I have. 
Any contribution to the growth and accessibility of this project would be greatly appreciated. Whether that's a Pull Request, an Issue, or just a watch or star. 

If you are interested in contributing directly to the code base, please have a look at the design documentation to get an overview of the project's code structure and systems.

# License

Licensed under the GNU General Public License version 3

[GNU GPL v3](./LICENSE)
