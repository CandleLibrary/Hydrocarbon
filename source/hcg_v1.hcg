################################################################################
############################# Hydrocarbon Grammar ##############################
################################################################################

# This is a preamble clause. It allow meta information to be defined at the head
# of a HCG grammar file. This particular preamble "@NAME" is used to define the 
# name of the grammer

@NAME Hydrocarbon Grammar Definition

# The @EXT preamble defines the extension types that this grammar is expected
# to parse

@EXT hcg

# The @SYMBOL preamble defines new symbol terminals for the lexer to recognize

@SYMBOL (( )) -- @PREC @SYMBOL @IGNORE @NAME @EXT

# The @IGNORE preamble defines tokens that should be ignored when encountered in
# productions. Can be overriden per production body with special condition clauses

@IGNORE θws θnl

# Hydrocarbon expect the first production to be the goal production. All other 
# productions should resolve to this one.

-- S → head												 			↦return {  sym[0] }

-- head → preamble productions 				 						
						   											↦cstr{ this.pre = sym[0]; this.productions = sym[1] }

-- preamble → preamble_clauses										
	│ ɛ

-- preamble_clauses → preamble_clause 								↦return {  [sym[0]]  }
	│ preamble_clauses preamble_clause 								↦return {  sym[0].push(sym[1]), sym[0] }

-- preamble_clause →  ignore_preamble
	│ symbols_preamble
	│ precedence_preamble
	│ name_preamble
	│ ext_preamble
	│ comment  	

-- symbols_preamble → 		@SYMBOL ignore_symbols θnl 				↦cstr{ this.type='symbols'; this.symbols = sym[1] }
-- precedence_preamble → 	@PREC terminal_symbol θnum θnl 			↦cstr{ this.type='precedence'; this.terminal = sym[1]; this.val = parseInt(sym[2]) }
-- ignore_preamble → 		@IGNORE ignore_symbols θnl				↦cstr{ this.type='ignore'; this.symbols = sym[1] }
-- name_preamble → 			@NAME comment_data θnl 					↦cstr{ this.type='name'; this.id = sym[1] }
-- ext_preamble → 			@EXT identifier θnl 					↦cstr{ this.type='ext'; this.id = sym[1] }

-- productions → production  										↦return {  [sym[0]] }
			│ productions production 	 							↦return {  sym[0].push(sym[1]), sym[0] }
			│ productions comment 	 							    ↦return {  sym[0] }
			│ ɛ 	
 
-- production → \-- production_id \→ production_bodies  			↦cstr{ this.name = sym[0]; this.bodies = sym[2]; this.id = -1; }

-- production_bodies → production_body 					 			↦return {  [sym[0]]  }
			│ production_bodies \│ production_body 					↦return {  sym[0].push(sym[2]), sym[0] }

-- production_body → entries  											


-- entries → body_entries 											↦cstr{ this.body = sym[0]; this.body_functs = null	}
		│ body_entries reduce_function 								↦cstr{ this.body = sym[0]; this.body_functs = sym[1] }
		│ body_entries EOF_symbol reduce_function 					↦cstr{ this.body = sym[0]; this.body_functs = sym[1] }
		│ empty_symbol  											↦cstr{ this.body = new Object(); this.body_functs = null; this.body.length = 0; this.body.sym = [sym[0]]; }
		│ EOF_symbol  												↦cstr{ this.body = new Object(); this.body_functs = null; this.body.length = 0; this.body.sym = [sym[0]]; }

-- body_entries → symbol 											↦cstr{ this.sym = [sym[0]]; this.length = 1; this.conditions = []; this.functions = []; }
  			 │ condition_clause 									↦cstr{ this.sym = []; this.length = 0; this.conditions = [sym[0]]; this.functions = []; sym[0].offset = this.length; }
  			 │ function_clause	 									↦cstr{ this.sym = []; this.length = 0; this.conditions = []; this.functions = [sym[0]]; sym[0].offset = this.length; }
			 │ body_entries function_clause 						↦return {  (sym[0].functions.push(sym[1]),  sym[1].offset = sym[0].length, sym[0]) }
			 │ body_entries condition_clause 						↦return {  (sym[0].conditions.push(sym[1]),  sym[1].offset = sym[0].length, sym[0]) }
			 │ body_entries symbol 									↦return {  (sym[0].sym.push(sym[1]), sym[0].length++, sym[0]) }

-- condition_clause → \(( τEXC condition_symbol_list )) 			↦cstr{ this.type = "exc"; this.id = sym[2] }
				 │ \(( τERR condition_symbol_list )) 				↦cstr{ this.type = "err"; this.id = sym[2] }
				 │ \(( τIGN condition_symbol_list )) 				↦cstr{ this.type = "ign"; this.id = sym[2] }


-- condition_symbol_list → terminal_symbol  						↦return {  [sym[0]] }
	│ condition_symbol_list terminal_symbol 						↦return {  sym[0].push(sym[1]), sym[0] }

-- ignore_symbols → ignore_symbol  									↦return {  [sym[0]] }
	│ ignore_symbols ignore_symbol 								    ↦return {  sym[0].push(sym[1]), sym[0] }

-- ignore_symbol → generated_symbol
	│ literal_symbol
	│ θany

-- terminal_symbol → generated_symbol
	│ literal_symbol
	│ escaped_symbol
	│ θany 															↦cstr{ this.type = "symbol"; this.id = sym[0] }

-- symbol → generated_symbol
	│ production_symbol
	│ literal_symbol
	│ escaped_symbol
	│ θany 															↦cstr{ this.type = "symbol"; this.id = sym[0] }

-- EOF_symbol → \$  												↦cstr{ this.type = "eof"; }
-- empty_symbol → \ɛ  												↦cstr{ this.type = "empty";  }
-- generated_symbol → \θ ((ERR θws )) ((ERR θnl )) identifier 		↦cstr{ this.type = "generated"; this.id = sym[1] }
-- literal_symbol → \τ ((ERR θws )) ((ERR θnl )) identifier 		↦cstr{ this.type = "literal"; this.id = sym[1] }
-- escaped_symbol → \\ ((ERR θws )) ((ERR θnl )) θsym 				↦cstr{ this.type = "escaped"; this.id = sym[1] }
-- production_symbol → identifier 									↦cstr{ this.type = "production"; this.id = sym[0]; this.val = -1 }

-- production_id → identifier 

-- identifier → θid


-- comment → \# comment_data comment_delimiter						↦cstr{ this.val = sym[1] }

-- comment_delimiter → θnl │ $ │ ;

-- comment_data → comment_primitive 								↦return { sym[0] }
			 │ comment_data comment_primitive						↦return { sym[0] + sym[1] }

-- comment_primitive → θid │ θnum │ θws │ θany

-- reduce_function → \↦ τcstr { comment_data } 						↦cstr{ this.type = "CLASS"; 		this.txt = sym[3]; this.name = ""; 	this.env = false;	}
		│ \↦ τreturn { comment_data } 								↦cstr{ this.type = "RETURNED"; 	this.txt = sym[3]; this.name = ""; 	this.env = false;}
 		│ \↦ τcstr ^ identifier 									↦cstr{ this.type = "CLASS"; 		this.txt = ""; 	   this.name = sym[3]; this.env = true;}

-- function_clause → \↦ { comment_data } 							↦cstr{this.type = "INLINE"; 	this.txt = sym[2]; this.name = ""; 	this.env = false;}
		│ \↦ ^ identifier 										 	↦cstr{this.type = "INLINE"; 	this.txt = sym[2]; this.name = sym[3]; 	this.env = true;}

