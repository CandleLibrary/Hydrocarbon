########################################################################################################################
############################################## Hydrocarbon Grammar #####################################################
########################################################################################################################

# This is a preamble clause. It allows meta information to be defined at the head of a HCG grammar file. This particular 
# preamble, @NAME, is used to define the name of the grammer

@NAME Hydrocarbon Grammar

# The @EXT preamble defines the extension types that this grammar is expected to parse.

@EXT hcg

# The @SYMBOL preamble defines symbols for the lexer to recognize and tokenize. This is useful when there is a need to 
# identify symbols that are comprised of multiple characters. 

@SYMBOL <> +> @PREC @SYMBOL @IGNORE @IMPORT @NAME @EXT => (* (+ :: $eof

# The @IGNORE preamble defines tokens that should be ignored when encountered in productions. Can be overriden per 
# production body with the ((IGN symbol)) clause or a by explicitly declaring the symbol within the grammar.

@IGNORE θws θnl

# Hydrocarbon expects the first production to be the goal production. All other productions should resolve to this one.

<> S → head												 			↦return {  env.productions }

# Hydrocarbon uses several non-ASCII characters in its syntax to define different constructs. 

<> head → preamble productions 				 						↦return { env.productions.meta = $sym1}

########################################################################################################################
######################################  PREAMBLES
########################################################################################################################



<> preamble → preamble_clauses										
	│ ɛ

<> preamble_clauses → preamble_clause 								↦return {  [$sym1]  }
	│ preamble_clauses preamble_clause 								↦return {  $sym1.push($sym2), $sym1 }

<> preamble_clause →  ignore_preamble
	│ symbols_preamble
	│ precedence_preamble
	│ name_preamble
	│ ext_preamble
	│ import_preamble
	│ comment 


<> symbols_preamble → 		@SYMBOL lexer_symbols θnl 				↦cstr{ 
																			this.type="symbols"; 
																			this.symbols = $sym2;
																			this.symbols.forEach(lex.addSymbol.bind(lex));
																		 }

<> precedence_preamble → 	@PREC terminal_symbol θnum θnl 			↦cstr{ this.grammar_stamp = env.stamp; 
																			this.type="precedence"; 
																		   this.terminal = $sym2; 
																		   this.val = parseInt($sym1) }

<> ignore_preamble → 		@IGNORE ignore_symbols θnl				↦cstr{ this.grammar_stamp = env.stamp; this.type="ignore"; this.symbols = $sym2 }

<> name_preamble → 			@NAME comment_data θnl 					↦cstr{ this.type="name"; this.id = $sym2 }

<> ext_preamble → 			@EXT identifier θnl 					↦cstr{ this.type="ext"; this.id = $sym2 }

<> import_preamble → 		@IMPORT θws(*) ( θid │ θany )(+") θws(+) (τAS│τas) θid θnl 	↦return ^importData 

########################################################################################################################
######################################  PRODUCTIONS
########################################################################################################################

<> productions → production  										↦return {  env.productions.push($sym1) }
			│ referenced_function									↦return {  env.refs.set($sym1.id, $sym1), null }
			│ productions production 	 							↦return {  $sym2.id = env.productions.length, env.productions.push($sym2), env.productions }
			│ productions comment 	 							    ↦return {  env.productions }
			│ productions referenced_function						↦return {  env.refs.set($sym2.id, $sym2), $sym1 }
			│ ɛ 	
 
<> production → \<>  production_id  \→ ↦{env.host_lex = lex.copy(); env.prod_name = sym[sym.length - 1];} production_bodies  			
																		
																		↦cstr{ 
																			this.name = $sym2; 
																			this.bodies = sym[3]; 
																			this.id = -1; 
																			env.functions.compileProduction(this);
																		}

	│ <> imported_production_symbol \→ ↦{env.host_lex = lex.copy(); env.prod_name = sym[sym.length - 1];} production_bodies

																		↦cstr{ 
																			this.IMPORT_OVERRIDE = true;
																			this.name = $sym2; 
																			this.bodies = sym[3]; 
																			this.id = -1; 
																			env.functions.compileProduction(this);
																		}

	│ +> imported_production_symbol \→ ↦{env.host_lex = lex.copy(); env.prod_name = sym[sym.length - 1];} production_bodies

																		↦cstr{ 
																			this.IMPORT_APPEND = true;
																			this.name = $sym2; 
																			this.bodies = sym[3]; 
																			this.id = -1; 
																			env.functions.compileProduction(this);
																		}

########################################################################################################################
######################################  PRODUCTION BODIES
########################################################################################################################

<> production_bodies → production_body 					 			↦return { env.body_count++, [$sym1]  }
			
			│ production_bodies \│ ↦{env.host_lex = lex.copy()} production_body 					
																	
																	↦return {  env.body_count++, $sym1.push($sym3), $sym1 }

			│ production_bodies comment 					
																	
																	↦return {  $sym1 }

<> production_body → entries  										↦cstr ^body


<> entries → body_entries 											↦cstr{ this.body = $sym1; this.reduce = null}

		│ body_entries reduce_function 								↦cstr{ this.body = $sym1; this.reduce = $sym2}								

		│ empty_symbol  											↦cstr{ 
																		   	this.body = []; 
																		   	this.reduce = null; }

		│ EOF_symbol  												↦cstr{ 
																		   	this.reduce = null;  
																		   	this.body = [$sym1]; 
																		   }


<> body_entries → symbol 											↦return{ env.body_offset = 0, [$sym1] }

  			 │ condition_clause 									↦return{ env.body_offset = 0, [$sym1] }

  			 │ function_clause	 									↦return{ env.body_offset = 0, [$sym1] }

			 │ body_entries function_clause 						↦return { env.body_offset = $sym1.length, $sym1.push($sym2), $sym1 }

			 │ body_entries condition_clause 						↦return { env.body_offset = $sym1.length, $sym1.push($sym2), $sym1 }

			 │ body_entries symbol 									↦return { env.body_offset = $sym1.length,  $sym1.push($sym2), $sym1 }

			 │ \[ body_entries \]										↦return { $sym2.map(e => (e.NO_BLANK = true, e))}


<> condition_clause → \( τEXC condition_symbol_list \) 				↦cstr{ this.type = "exc"; this.sym = $sym3; this.offset = -1; }
				 │ \( τERR condition_symbol_list \) 				↦cstr{ this.type = "err"; this.sym = $sym3; this.offset = -1; }
				 │ \( τIGN condition_symbol_list \) 				↦cstr{ this.type = "ign"; this.sym = $sym3; this.offset = -1; }


########################################################################################################################
######################################  SYMBOLS
########################################################################################################################

<> condition_symbol_list → terminal_symbol  						↦return {  [$sym1] }
	│ condition_symbol_list terminal_symbol 						↦return {  $sym1.push($sym2), $sym1 }

<> lexer_symbols → lexer_symbol 									↦return {  [ $sym1 ] }
	│ lexer_symbols lexer_symbol 								    ↦return {  $sym1.push($sym2), $sym1 }

<> ignore_symbols → ignore_symbol  									↦return {  [$sym1] }
	│ ignore_symbols ignore_symbol 								    ↦return {  $sym1.push($sym2), $sym1 }

<> lexer_symbol → generated_symbol
	│ literal_symbol
	│ escaped_symbol
	│ grouped_symbol grouped_delimiter								↦return { $sym1 }

<> grouped_delimiter →  θnl │ θws									

<> grouped_symbol →  θany 																					
	│ grouped_symbol θany  											↦return { $sym1 + $sym2 }

<> ignore_symbol → generated_symbol
	│ literal_symbol
	│ escaped_symbol
	│ θany

<> terminal_symbol → generated_symbol
	│ literal_symbol
	│ escaped_symbol
	│ θany 															↦cstr{ this.type = "symbol"; this.val = $sym1 }

<> symbol → generated_symbol
	│ production_symbol
	│ imported_production_symbol
	│ literal_symbol
	│ escaped_symbol
	│ symbol \? 													↦return{ $sym1.IS_OPTIONAL = true, $sym1 }	
	
	# separated list of productions
	│ symbol ( \(+ │ \(* )  terminal_symbol?  \) 					↦cstr ^listProduction

	│ \( production_bodies \) 										↦cstr ^groupProduction	
	│ θany															↦cstr{ this.type = "symbol"; this.val = $sym1 }

<> EOF_symbol → \$eof  												↦cstr{ this.type = "eof"; this.val = "$" }
<> empty_symbol → \ɛ  												↦cstr{ this.type = "empty";  }
<> generated_symbol → \θ (ERR θws θnl) identifier 					↦cstr{ this.type = "generated"; this.val = $sym2 }
<> literal_symbol → \τ (ERR θws θnl)  identifier 					↦cstr{ this.type = "literal"; this.val = $sym2 }
<> escaped_symbol → \\ (ERR θws θnl)  θany 							↦cstr{ this.type = "escaped"; this.val = $sym2 }
<> production_symbol → identifier 									↦cstr{ this.type = "production"; this.name = $sym1; this.val = -1}
<> imported_production_symbol → θid \:: θid							↦c ^importProduction
<> production_id → identifier 
<> identifier → θid 												


########################################################################################################################
######################################  COMMENTS
########################################################################################################################

<> comment → \# comment_data comment_delimiter						↦cstr{ this.val = $sym2 }

<> comment_delimiter → θnl │ $eof │ ;

<> comment_data → comment_primitive 								↦return { $sym1 }
			 │ comment_data comment_primitive						↦return { $sym1 + $sym2 }

<> comment_primitive → θid │ θnum │ θws │ θany


########################################################################################################################
######################################  FUNCTIONS
########################################################################################################################

<> referenced_function → \↦  identifier  ^ (ERR θws ) identifier  		
																		↦cstr{ 		
																			this.id = $sym2; 	
																			this.name = $sym4;
																			this.txt = ""; 
																			this.env = true;	
																		}

		│ \↦  identifier  { js_data }  		
																		↦cstr{ 		
																			this.id = $sym2; 	
																			this.txt = $sym4; 
																			this.env = false;	
																			this.name = "";
																		}

<> reduce_function → 

		\↦ ( τcstr │ τc │ τreturn │ τr ) { js_data } 								
																		↦cstr{ 
																			this.type = ($sym2[0] == "c" ) ?"CLASS" :"RETURNED"; 	
																			this.txt = $sym4; 
																			this.name = ""; 
																			this.env = false;
																			this.ref = ""; 	
																		}

 		│ \↦ ( τcstr │ τc │ τreturn │ τr ) ^ (ERR θws θnl ) identifier 								
 																	↦cstr{ 
 																			this.type = ($sym2[0] == "c" ) ?"CLASS" :"RETURNED"; 			
																			this.txt = ""; 
																			this.name = $sym4; 
																			this.env = true;
																			this.ref = ""; 	   
																		}
		│ \↦ ( τcstr │ τc │ τreturn │ τr ) =>  identifier	
																	↦cstr{ 
																			this.type = ($sym2[0] == "c" ) ?"CLASS" :"RETURNED"; 			
																			this.ref = $sym4;
																			this.txt = ""; 	   
																			this.name = ""; 
																			this.env = true;

																			const ref = env.refs.get(this.ref);

																			if(ref){
																				if(Array.isArray(ref)){
																					ref.push(this);
																				}
																				else{
																					let ref = env.refs.get(this.ref);
																					this.env = ref.env;
																					this.name = ref.name;
																					this.txt = ref.txt;
																				}
																			}else{
																				env.refs.set(this.ref, [this]);
																			}
																			
																		}

<> function_clause → \↦ { js_data } 								↦cstr{this.type = "INLINE"; 	
																			this.txt = $sym3; 
																			this.name = ""; 	
																			this.env = false;
																		}

		│ \↦ ^ (ERR θws θnl ) identifier 									↦cstr{this.type = "INLINE"; 	
																			this.txt = ""; 
																			this.name = $sym3; 	
																			this.env = true;
																		}

<> js_data → comment_data
		│ js_data_block
		│ js_data js_data											↦return { $sym1 + $sym2 }
		│ ɛ

<> js_data_block → { js_data  } 									↦return { $sym1 + $sym2 + $sym3 }
