########################################################################################################################
############################################## Hydrocarbon Grammar #####################################################
########################################################################################################################

# This is a preamble clause. It allows meta information to be defined at the head of a HCG grammar file. This particular 
# preamble, @NAME, is used to define the name of the grammer

@NAME Hydrocarbon Grammar

# The @EXT preamble defines the extension types that this grammar is expected to parse.

@EXT hcg

# The @SYMBOL preamble defines symbols for the lexer to recognize and tokenize. This is useful when there is a need to 
# identify symbols that are comprised of multiple characters. 

@SYMBOL (( )) <> +> @PREC @SYMBOL @IGNORE @IMPORT @NAME @EXT => (* (+ ::

# The @IGNORE preamble defines tokens that should be ignored when encountered in productions. Can be overriden per 
# production body with the ((IGN symbol)) clause or a by explicitly declaring the symbol within the grammar.

@IGNORE θws θnl

# Hydrocarbon expects the first production to be the goal production. All other productions should resolve to this one.

<> S → head												 			↦return {  env.productions }

# Hydrocarbon uses several non-ASCII characters in its syntax to define different constructs. 

<> head → preamble productions 				 						↦return { env.productions.meta = sym[0]}

########################################################################################################################
######################################  PREAMBLES
########################################################################################################################



<> preamble → preamble_clauses										
	│ ɛ

<> preamble_clauses → preamble_clause 								↦return {  [sym[0]]  }
	│ preamble_clauses preamble_clause 								↦return {  sym[0].push(sym[1]), sym[0] }

<> preamble_clause →  ignore_preamble
	│ symbols_preamble
	│ precedence_preamble
	│ name_preamble
	│ ext_preamble
	│ import_preamble
	│ comment 


<> symbols_preamble → 		@SYMBOL lexer_symbols θnl 				↦cstr{ 
																			this.type='symbols'; 
																			this.symbols = sym[1];
																			this.symbols.forEach(lex.addSymbol.bind(lex));
																		 }

<> precedence_preamble → 	@PREC terminal_symbol θnum θnl 			↦cstr{ this.grammar_stamp = env.stamp; 
																			this.type='precedence'; 
																		   this.terminal = sym[1]; 
																		   this.val = parseInt(sym[2]) }

<> ignore_preamble → 		@IGNORE ignore_symbols θnl				↦cstr{ this.grammar_stamp = env.stamp; this.type='ignore'; this.symbols = sym[1] }

<> name_preamble → 			@NAME comment_data θnl 					↦cstr{ this.type='name'; this.id = sym[1] }

<> ext_preamble → 			@EXT identifier θnl 					↦cstr{ this.type='ext'; this.id = sym[1] }

<> import_preamble → 		@IMPORT θws(*) (( θid │ θany ))(+") θws(+) ((τAS│τas)) θid θnl 	↦return ^importData 

########################################################################################################################
######################################  PRODUCTIONS
########################################################################################################################

<> productions → production  										↦return {  (!(sym[0].IMPORT_OVERRIDE || sym[0].IMPORT_APPEND)) ? env.productions.push(sym[0]) : 0 }
			│ referenced_function									↦return {  env.refs.set(sym[0].id, sym[0]), null }
			│ productions production 	 							↦return {  sym[1].id = env.productions.length, (!(sym[1].IMPORT_OVERRIDE || sym[1].IMPORT_APPEND)) ? env.productions.push(sym[1]) : 0, env.productions }
			│ productions comment 	 							    ↦return {  env.productions }
			│ productions referenced_function						↦return {  env.refs.set(sym[1].id, sym[1]), sym[0] }
			│ ɛ 	
 
<> production → \<>  production_id  \→ ↦{env.host_lex = lex.copy(); env.prod_name = sym[sym.length - 1];} production_bodies  			
																		
																		↦cstr{ 
																			this.name = sym[1]; 
																			this.bodies = sym[3]; 
																			this.id = -1; 
																			env.functions.compileProduction(this);
																		}

	│ <> imported_production_symbol \→ ↦{env.host_lex = lex.copy(); env.prod_name = sym[sym.length - 1].name;} production_bodies

																		↦cstr{ 
																			this.IMPORT_OVERRIDE = true;
																			this.name = sym[1]; 
																			this.bodies = sym[3]; 
																			this.id = -1; 
																			env.functions.compileProduction(this);
																		}

	│ +> imported_production_symbol \→ ↦{env.host_lex = lex.copy(); env.prod_name = sym[sym.length - 1].name;} production_bodies

																		↦cstr{ 
																			this.IMPORT_APPEND = true;
																			this.name = sym[1]; 
																			this.bodies = sym[3]; 
																			this.id = -1; 
																			env.functions.compileProduction(this);
																		}

########################################################################################################################
######################################  PRODUCTION BODIES
########################################################################################################################

<> production_bodies → production_body 					 			↦return { env.body_count++, [sym[0]]  }
			
			│ production_bodies \│ ↦{env.host_lex = lex.copy()} production_body 					
																	
																	↦return {  env.body_count++, sym[0].push(sym[2]), sym[0] }

			│ production_bodies comment 					
																	
																	↦return {  sym[0] }

<> production_body → entries  										↦cstr ^body


<> entries → body_entries 											↦cstr{ this.body = sym[0]; this.reduce = null}

		│ body_entries reduce_function 								↦cstr{ this.body = sym[0]; this.reduce = sym[1]}								

		│ empty_symbol  											↦cstr{ 
																		   	this.body = []; 
																		   	this.reduce = null; }

		│ EOF_symbol  												↦cstr{ 
																		   	this.reduce = null;  
																		   	this.body = [sym[0]]; 
																		   }


<> body_entries → symbol 											↦return{ env.body_offset = 0, [sym[0]] }

  			 │ condition_clause 									↦return{ env.body_offset = 0, [sym[0]] }

  			 │ function_clause	 									↦return{ env.body_offset = 0, [sym[0]] }

			 │ body_entries function_clause 						↦return { env.body_offset = sym[0].length, sym[0].push(sym[1]), sym[0] }

			 │ body_entries condition_clause 						↦return { env.body_offset = sym[0].length, sym[0].push(sym[1]), sym[0] }

			 │ body_entries symbol 									↦return { env.body_offset = sym[0].length,  sym[0].push(sym[1]), sym[0] }

			 │ body_entries \!										↦return { sym[0].map(e => (e.NO_BLANK = true, e))}


<> condition_clause → \(( τEXC condition_symbol_list \)) 			↦c{ this.type = "exc"; this.sym = sym[2]; this.offset = -1; }
				 │ \(( τERR condition_symbol_list \)) 				↦c{ this.type = "err"; this.sym = sym[2]; this.offset = -1; }
				 │ \(( τIGN condition_symbol_list \)) 				↦c{ this.type = "ign"; this.sym = sym[2]; this.offset = -1; }


########################################################################################################################
######################################  SYMBOLS
########################################################################################################################

<> condition_symbol_list → terminal_symbol  						↦return {  [sym[0]] }
	│ condition_symbol_list terminal_symbol 						↦return {  sym[0].push(sym[1]), sym[0] }

<> lexer_symbols → lexer_symbol 									↦return {  [ sym[0] ] }
	│ lexer_symbols lexer_symbol 								    ↦return {  sym[0].push(sym[1]), sym[0] }

<> ignore_symbols → ignore_symbol  									↦return {  [sym[0]] }
	│ ignore_symbols ignore_symbol 								    ↦return {  sym[0].push(sym[1]), sym[0] }

<> lexer_symbol → generated_symbol
	│ literal_symbol
	│ escaped_symbol
	│ grouped_symbol grouped_delimiter								↦return { sym[0] }

<> grouped_delimiter →  θnl │ θws									

<> grouped_symbol →  θany 																					
	│ grouped_symbol θany  											↦return { sym[0] + sym[1] }


<> ignore_symbol → generated_symbol
	│ literal_symbol
	│ escaped_symbol
	│ θany

<> terminal_symbol → generated_symbol
	│ literal_symbol
	│ escaped_symbol
	│ θany 															↦cstr{ this.type = "symbol"; this.val = sym[0] }

<> symbol → generated_symbol
	│ production_symbol
	│ imported_production_symbol
	│ literal_symbol
	│ escaped_symbol
	│ θany															↦cstr{ this.type = "symbol"; this.val = sym[0] }
	│ symbol \? 													↦return{ sym[0].IS_OPTIONAL = true, sym[0] }	
	
	# separated list of productions
	│ symbol (( (+ │ (* ))  terminal_symbol?  ) 					↦cstr ^listProduction

	│ \(( production_bodies \)) 									↦cstr ^groupProduction	

<> EOF_symbol → \$  												↦cstr{ this.type = "eof"; this.val = "$" }
<> empty_symbol → \ɛ  												↦cstr{ this.type = "empty";  }
<> generated_symbol → \θ ((ERR θws θnl)) identifier 				↦cstr{ this.type = "generated"; this.val = sym[1] }
<> literal_symbol → \τ ((ERR θws θnl))  identifier 					↦cstr{ this.type = "literal"; this.val = sym[1] }
<> escaped_symbol → \\ ((ERR θws θnl))  θany 						↦cstr{ this.type = "escaped"; this.val = sym[1] }
<> production_symbol → identifier 									↦cstr{ this.type = "production"; this.name = sym[0]; this.val = -1}
<> imported_production_symbol → θid :: θid							↦c ^importProduction
<> production_id → identifier 
<> identifier → θid 												


########################################################################################################################
######################################  COMMENTS
########################################################################################################################

<> comment → \# comment_data comment_delimiter						↦cstr{ this.val = sym[1] }

<> comment_delimiter → θnl │ $ │ ;

<> comment_data → comment_primitive 								↦return { sym[0] }
			 │ comment_data comment_primitive						↦return { sym[0] + sym[1] }

<> comment_primitive → θid │ θnum │ θws │ θany


########################################################################################################################
######################################  FUNCTIONS
########################################################################################################################

<> referenced_function → \↦  identifier  ^ ((ERR θws )) identifier  		
																		↦cstr{ 		
																			this.txt = ""; 
																			this.env = true;	
																			this.name = sym[3];
																			this.id = sym[1]; 	
																		}

		│ \↦  identifier  { js_data }  		
																		↦cstr{ 		
																			this.txt = sym[3]; 
																			this.env = false;	
																			this.name = "";
																			this.id = sym[1]; 	
																		}

<> reduce_function → 

		\↦ (( τcstr │ τc │ τreturn │ τr )) { js_data } 								
																		↦cstr{ 
																			this.type = (sym[1][0] == "c" ) ?"CLASS" :"RETURNED"; 	
																			this.txt = sym[3]; 
																			this.name = ""; 
																			this.env = false;
																			this.ref = ""; 	
																		}

 		│ \↦ (( τcstr │ τc │ τreturn │ τr )) ^ ((ERR θws θnl )) identifier 								
 																	↦cstr{ 
 																			this.type = (sym[1][0] == "c" ) ?"CLASS" :"RETURNED"; 			
																			this.txt = ""; 
																			this.name = sym[3]; 
																			this.env = true;
																			this.ref = ""; 	   
																		}
		│ \↦ (( τcstr │ τc │ τreturn │ τr )) =>  identifier	
																	↦cstr{ 
																			this.ref = sym[3];
																			this.type = (sym[1][0] == "c" ) ?"CLASS" :"RETURNED"; 			
																			this.txt = ""; 	   
																			this.name = ""; 
																			this.env = true;

																			const ref = env.refs.get(this.ref);

																			if(ref){
																				if(Array.isArray(ref)){
																					ref.push(this);
																				}
																				else{
																					let ref = env.refs.get(this.ref);
																					this.env = ref.env;
																					this.name = ref.name;
																					this.txt = ref.txt;
																				}
																			}else{
																				env.refs.set(this.ref, [this]);
																			}
																			
																		}

<> function_clause → \↦ { js_data } 								↦cstr{this.type = "INLINE"; 	
																			this.txt = sym[2]; 
																			this.name = ""; 	
																			this.env = false;
																		}

		│ \↦ ^ ((ERR θws θnl )) identifier 									↦cstr{this.type = "INLINE"; 	
																			this.txt = ""; 
																			this.name = sym[2]; 	
																			this.env = true;
																		}

<> js_data → comment_data
		│ js_data_block
		│ js_data js_data											↦return { sym[0] + sym[1] }
		│ ɛ

<> js_data_block → { js_data }										↦return { sym[0] + sym[1] + sym[2] }
